import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.*;
import java.sql.*; 
import java.util.Date;
import java.text.SimpleDateFormat;
import java.text.DateFormat;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import org.xml.sax.helpers.DefaultHandler;

public class actorsSAX extends DefaultHandler{

   static List myActors;

   private static Connection con = ConnectionManager.getConnection();
   // static Map<String,Integer> actors = null;     
   // static Map<Film,Integer> movies = null;     

   
   private String tempVal;
   private static Map<String,Integer> actors; 
   
   // //to maintain context
   private Actor tempActor;
   
   public actorsSAX(){
      myActors = new ArrayList();
   }
   
   public Map<String,Integer> run() {
      actors = storeAllActorsInAMap();
      parseDocument();
      return actors; 
      // printData();
   }

   private void parseDocument() {
      
      //get a factory
      SAXParserFactory spf = SAXParserFactory.newInstance();
      try {
      
         //get a new instance of parser
         SAXParser sp = spf.newSAXParser();
         
         //parse the file and also register this class for call backs
         sp.parse("actors63.xml", this);
         
      }catch(SAXException se) {
         se.printStackTrace();
      }catch(ParserConfigurationException pce) {
         pce.printStackTrace();
      }catch (IOException ie) {
         ie.printStackTrace();
      }
   }

   // /**
   //  * Iterate through the list and print
   //  * the contents
   //  */
   private void printData(){
      Iterator it = myActors.iterator();
      while(it.hasNext()) {
         System.out.println(it.next().toString());
      }
   }

   

   // //Event Handlers
   public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
      //reset
      tempVal = "";
      if(qName.equalsIgnoreCase("actor")) {
         //create a new instance of employee
         tempActor = new Actor();
         // tempFilm.setType(attributes.getValue("type"));
      }
   }
   

   public void characters(char[] ch, int start, int length) throws SAXException {
      tempVal = new String(ch,start,length);
   }
   
   public void endElement(String uri, String localName, String qName) throws SAXException {
      if(qName.equalsIgnoreCase("actor")) {
         //add it to the list
         if (!tempActor.emptyStageName()){ // if stagename is not "" then add it to the myFilms list
            myActors.add(tempActor);
            if (myActors.size() > 1000) {
               insertActorsInDatabase(myActors);
               myActors.clear();
            }
         }
         else 
            System.out.println("Inconsistent Empty Node Name " + qName + ", value : " + tempVal);

      // using stagename to derive first and last name
      // stagename serves as the key to verify if star already exists.
      }else if (qName.equalsIgnoreCase("actors")) { 
         insertActorsInDatabase(myActors);
         myActors.clear();      
      }else if (qName.equalsIgnoreCase("stagename")) {
         tempVal = tempVal.replaceAll("[^a-zA-Z0-9\\s]", ""); 
         tempActor.setstagename(tempVal);
         tempActor.setFirstAndLastName(tempVal);
         // String[] splitArray = tempVal.split(" ");
         // tempActor.setfirstname(splitArray[0]);
         // if (splitArray.length > 1)
         //    tempActor.setlastname(splitArray[1]);
      }else if (qName.equalsIgnoreCase("dob")) {
         Date date = new Date();
         String d = new String();
         DateFormat format = new SimpleDateFormat("yyyy");
         SimpleDateFormat df2 = new SimpleDateFormat("yyyy/dd/MM");
         if (tempVal.equals("") || !isNumeric(tempVal))
            tempVal = "1900";
         try {
            date = format.parse(tempVal);
            d = df2.format(date);
         } catch(Exception e) {

         }
         tempActor.setdob(d);
      }
   }

   public static void insertActorsInDatabase(List<Actor> actorList) {
      Statement statement = null; 
      ResultSet rs = null; 
      int current_id = 0;
      try {
         statement = con.createStatement();
         rs = statement.executeQuery("SELECT LAST_INSERT_ID();");
         
         if(rs.next())
            current_id = rs.getInt("LAST_INSERT_ID()");
      } catch (Exception e){  
         System.out.println("failed to grab current id");
         return; 
      }

      ++current_id; // the next id that will be autogenerated
      String batchInsertQuery = "insert into stars (first_name,last_name, dob) values";

      Iterator it = actorList.iterator();
      while(it.hasNext()) {
         Actor a = (Actor) it.next();
         if (!actorHasBeenAdded(actors,a.getstagename())) {
            batchInsertQuery += " ('" + a.getfirstname() +"', '" + a.getlastname() + "', " +
               "'"+ a.getdob() + "'" + "),"; // *** fix the date here"
         }
         else // if actor is repeated then remove it from my list. 
            it.remove();

      }

      batchInsertQuery = batchInsertQuery.substring(0, batchInsertQuery.length() - 1) + ";";
      // System.out.println("query: " + batchInsertQuery);
      try {
         con.setAutoCommit(false);
         statement.executeUpdate(batchInsertQuery);
         statement.close();
         con.commit();
         // the batch was succesful and i can assume all the actors 
         // in the list are now in the db
         for (Actor a : actorList){
            actors.put(a.getstagename(), current_id);
            ++current_id; 
         }
      } catch (Exception e) {
               //System.out.println(e.getMessage());
      }  
      statement = null;
      rs = null; 
   }

   public static boolean actorHasBeenAdded(Map<String,Integer> actors, String stagename) {
      if (actors.containsKey(stagename)){
         return true;
      }
      else{
         // System.out.println(stagename);
         return false; 
      }
   }

   public static boolean isNumeric(String str)
   {
   for (char c : str.toCharArray())
      {
         if (!Character.isDigit(c)) return false;
      }
       return true;
   }

   public static Map<String,Integer> storeAllActorsInAMap() {
   // public static Map<Film,Integer> storeAllMovieTittlesInAMap() {
      Map<String,Integer> map = new HashMap<String,Integer>();
      // Map<Film,Integer> map = new HashMap<Film,Integer>();
      String query = "select * from stars;";
      Statement statement = null;
      ResultSet rs = null; 
      try {
         statement = con.createStatement();
         rs = statement.executeQuery(query);
         while (rs.next()) {
            try {
               // map.put(new Film(rs.getString("title"),
               //    rs.getString("director"),rs.getInt("year")),rs.getInt("id"));
               String fname = "";
               String lname = "";
               String dbfname = rs.getString("first_name");
               String dblname = rs.getString("last_name");
               if (dbfname.equals("") && !dblname.equals(""))
                  map.put(dblname,rs.getInt("id")); 
               else if (!dbfname.equals("") && dblname.equals(""))
                  map.put(dbfname,rs.getInt("id"));
               else 
                  map.put(dbfname + " " + dblname, rs.getInt("id"));
               // map.put(rs.getString("title"),rs.getInt("id"));
            } catch (Exception e){
               // System.out.println(e.getMessage());

            }
         } 
      } catch (SQLException  e) {
         return null; 
      } finally {
         statement = null;
         rs = null; 
      }
      return map; 
   }    
}



